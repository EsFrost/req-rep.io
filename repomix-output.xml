This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
index.html
package.json
src/main/index.ts
src/main/ipc/handlers.ts
src/main/ipc/request-handler.ts
src/main/storage/collections.ts
src/main/storage/environments.ts
src/main/storage/history.ts
src/main/window.ts
src/preload/index.ts
src/renderer/components/EnvironmentSelector.ts
src/renderer/components/RequestBuilder.ts
src/renderer/components/ResponseViewer.ts
src/renderer/components/Sidebar.ts
src/renderer/components/TabsManager.ts
src/renderer/index.ts
src/renderer/services/api.ts
src/renderer/services/storage.ts
src/renderer/types/index.ts
src/shared/types.ts
src/styles/input.css
tailwind.config.js
tsconfig.json
tsconfig.renderer.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/main/index.ts">
import { app, BrowserWindow } from 'electron';
import { createWindow } from './window';
import { registerHandlers } from './ipc/handlers';

app.on('ready', () => {
  registerHandlers();
  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});
</file>

<file path="src/main/window.ts">
import { BrowserWindow } from 'electron';
import path from 'path';

export const createWindow = (): BrowserWindow => {
  const win = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: path.join(__dirname, '../preload/index.js'),
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  win.loadFile('index.html');
  
  return win;
};
</file>

<file path="src/preload/index.ts">
import { contextBridge, ipcRenderer } from 'electron';
import { FetchResponse } from '../shared/types';

contextBridge.exposeInMainWorld('electron', {
  fetchUrl: (url: string): Promise<FetchResponse> => ipcRenderer.invoke('fetch-url', url),
});
</file>

<file path="tailwind.config.js">
module.exports = {
  content: ["./*.html", "./dist/**/*.js"],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path=".gitignore">
node_modules
/node_modules
*node_modules/*

styles.css

dist
</file>

<file path="src/main/ipc/handlers.ts">
import { ipcMain } from 'electron';
import { exec } from 'child_process';
import { promisify } from 'util';
import { FetchResponse } from '../../shared/types';

const execAsync = promisify(exec);

export const registerHandlers = (): void => {
  ipcMain.handle('fetch-url', async (_event, url: string): Promise<FetchResponse> => {
    try {
      // Use curl with -w flag to get HTTP status code
      const { stdout, stderr } = await execAsync(`curl -s -w "\\n%{http_code}" "${url}"`);
      
      if (stderr) {
        return { success: false, error: stderr };
      }
      
      // Split response body and status code
      const lines = stdout.trim().split('\n');
      const statusCode = parseInt(lines[lines.length - 1]);
      const body = lines.slice(0, -1).join('\n');
      
      return { 
        success: true, 
        data: body,
        statusCode: statusCode
      };
    } catch (error) {
      return { success: false, error: (error as Error).message };
    }
  });
};
</file>

<file path="src/styles/input.css">
@import 'highlight.js/styles/atom-one-dark.css';

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer components {
  #result pre {
    @apply m-0 bg-transparent;
  }
  
  #result code {
    @apply block p-4 rounded font-mono text-sm leading-relaxed;
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true
  },
  "include": ["src/main/**/*", "src/preload/**/*", "src/shared/**/*"],
  "exclude": ["node_modules", "src/renderer/**/*"]
}
</file>

<file path="tsconfig.renderer.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ES2020",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "bundler",
    "resolveJsonModule": true
  },
  "include": ["src/renderer/**/*", "src/shared/**/*"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/renderer/index.ts">
import hljs from 'highlight.js';
import { FetchResponse } from '../shared/types';

declare global {
  interface Window {
    electron: {
      fetchUrl: (url: string) => Promise<FetchResponse>;
    };
  }
}

type DisplayFormat = 'raw' | 'json' | 'html' | 'xml';

const fetchButton = document.getElementById('fetch') as HTMLButtonElement;
const urlInput = document.getElementById('url') as HTMLInputElement;
const resultDiv = document.getElementById('result') as HTMLDivElement;
const formatSelect = document.getElementById('format-select') as HTMLSelectElement;
const statusCodeSpan = document.getElementById('status-code') as HTMLSpanElement;

let currentFormat: DisplayFormat = 'raw';
let lastResponse: string = '';

const getStatusText = (code: number): string => {
  const statusTexts: Record<number, string> = {
    200: 'OK',
    201: 'Created',
    204: 'No Content',
    301: 'Moved Permanently',
    302: 'Found',
    304: 'Not Modified',
    400: 'Bad Request',
    401: 'Unauthorized',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    500: 'Internal Server Error',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Timeout'
  };
  return statusTexts[code] || 'Unknown';
};

const detectLanguage = (data: string): string => {
  const trimmed = data.trim();
  
  // Check for JSON
  if ((trimmed.startsWith('{') && trimmed.endsWith('}')) || 
      (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
    try {
      JSON.parse(trimmed);
      return 'json';
    } catch {
      // Not valid JSON
    }
  }
  
  // Check for XML
  if (trimmed.startsWith('<?xml') || 
      (trimmed.startsWith('<') && trimmed.includes('</') && trimmed.endsWith('>'))) {
    return 'xml';
  }
  
  // Check for HTML
  if (trimmed.toLowerCase().includes('<!doctype html') || 
      trimmed.toLowerCase().includes('<html')) {
    return 'html';
  }
  
  return 'plaintext';
};

const displayResponse = (data: string) => {
  lastResponse = data;
  resultDiv.innerHTML = '';
  
  const codeBlock = document.createElement('pre');
  const codeElement = document.createElement('code');
  
  switch (currentFormat) {
    case 'raw':
      // Auto-detect language for syntax highlighting
      const detectedLang = detectLanguage(data);
      codeElement.className = `language-${detectedLang}`;
      codeElement.textContent = data;
      codeBlock.appendChild(codeElement);
      resultDiv.appendChild(codeBlock);
      hljs.highlightElement(codeElement);
      break;
      
    case 'json':
      try {
        const parsed = JSON.parse(data);
        const formatted = JSON.stringify(parsed, null, 2);
        codeElement.className = 'language-json';
        codeElement.textContent = formatted;
        codeBlock.appendChild(codeElement);
        resultDiv.appendChild(codeBlock);
        hljs.highlightElement(codeElement);
      } catch {
        codeElement.className = 'language-plaintext';
        codeElement.textContent = 'Invalid JSON: ' + data;
        codeBlock.appendChild(codeElement);
        resultDiv.appendChild(codeBlock);
        hljs.highlightElement(codeElement);
      }
      break;
      
    case 'html':
      codeElement.className = 'language-html';
      codeElement.textContent = data;
      codeBlock.appendChild(codeElement);
      resultDiv.appendChild(codeBlock);
      hljs.highlightElement(codeElement);
      break;
      
    case 'xml':
      codeElement.className = 'language-xml';
      codeElement.textContent = data;
      codeBlock.appendChild(codeElement);
      resultDiv.appendChild(codeBlock);
      hljs.highlightElement(codeElement);
      break;
  }
};

formatSelect?.addEventListener('change', () => {
  currentFormat = formatSelect.value as DisplayFormat;
  if (lastResponse) {
    displayResponse(lastResponse);
  }
});

fetchButton?.addEventListener('click', async () => {
  try {
    const response = await window.electron.fetchUrl(urlInput.value);
    if (response.success && response.statusCode) {
      const statusText = getStatusText(response.statusCode);
      statusCodeSpan.textContent = `${response.statusCode} ${statusText}`;
      
      // Green for 2xx status codes, red for others
      if (response.statusCode >= 200 && response.statusCode < 300) {
        statusCodeSpan.className = 'text-green-400 font-semibold';
      } else {
        statusCodeSpan.className = 'text-red-400 font-semibold';
      }
      
      displayResponse(response.data || '');
    } else {
      // Show error status
      statusCodeSpan.textContent = 'Error';
      statusCodeSpan.className = 'text-red-400 font-semibold';
      resultDiv.textContent = `Error: ${response.error}`;
    }
  } catch (error) {
    console.error(error);
    statusCodeSpan.textContent = 'Error';
    statusCodeSpan.className = 'text-red-400 font-semibold';
    resultDiv.textContent = 'An error occurred';
  }
});
</file>

<file path="src/shared/types.ts">
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';

export type AuthType = 'none' | 'basic' | 'bearer' | 'api-key' | 'oauth2';

export interface KeyValue {
  key: string;
  value: string;
  enabled: boolean;
}

export interface Auth {
  type: AuthType;
  basic?: {
    username: string;
    password: string;
  };
  bearer?: {
    token: string;
  };
  apiKey?: {
    key: string;
    value: string;
    addTo: 'header' | 'query';
  };
}

export type BodyType = 'none' | 'json' | 'form-data' | 'x-www-form-urlencoded' | 'raw' | 'binary';

export interface RequestBody {
  type: BodyType;
  raw?: string;
  json?: any;
  formData?: KeyValue[];
  binary?: string;
}

export interface Request {
  id: string;
  name: string;
  method: HttpMethod;
  url: string;
  headers: KeyValue[];
  body?: RequestBody;
  auth?: Auth;
  queryParams: KeyValue[];
  collectionId?: string;
  createdAt: number;
  updatedAt: number;
}

export interface FetchResponse {
  success: boolean;
  data?: string;
  error?: string;
  statusCode?: number;
}

export interface HttpResponse {
  status: number;
  statusText: string;
  headers: Record<string, string>;
  body: string;
  time: number;
  size: number;
  timestamp: number;
}

export interface Folder {
  id: string;
  name: string;
  requests: Request[];
  subfolders: Folder[];
}

export interface Collection {
  id: string;
  name: string;
  folders: Folder[];
  requests: Request[];
  createdAt: number;
  updatedAt: number;
}

export interface Environment {
  id: string;
  name: string;
  variables: KeyValue[];
  isActive: boolean;
}

export interface HistoryEntry {
  id: string;
  request: Request;
  response: HttpResponse;
  timestamp: number;
}

export interface IpcChannels {
  'request:send': {
    args: [Request];
    return: HttpResponse;
  };
  'collection:save': {
    args: [Collection];
    return: void;
  };
  'collection:load': {
    args: [];
    return: Collection[];
  };
  'environment:save': {
    args: [Environment];
    return: void;
  };
  'history:get': {
    args: [number?];
    return: HistoryEntry[];
  };
  'fetch-url': {
    args: [string];
    return: FetchResponse;
  };
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'"
    />
    <title>Req-Rep.io Electron</title>
    <link href="./styles.css" rel="stylesheet">
    <link href="./node_modules/highlight.js/styles/atom-one-dark.css" rel="stylesheet">
  </head>
  <body class="bg-gray-900 text-white p-8">
    <h1 class="text-3xl font-bold mb-4">Req.io</h1>
    <div class="mb-4 flex items-center gap-4">
      <input type="text" id="url" class="text-black p-2 rounded flex-1" placeholder="Enter URL">
      <button id="fetch" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">Fetch</button>
    </div>
    
    <div class="mb-4 flex items-center justify-between">
      <div class="flex items-center">
        <label for="format-select" class="mr-2">Response Format:</label>
        <select id="format-select" class="bg-gray-800 text-white p-2 rounded border border-gray-700 cursor-pointer">
          <option value="raw">Raw</option>
          <option value="json">JSON</option>
          <option value="html">HTML</option>
          <option value="xml">XML</option>
        </select>
      </div>
      <div>
        <span class="text-gray-400 mr-2">Status:</span>
        <span id="status-code" class="text-gray-500">-</span>
      </div>
    </div>
    
    <div id="result" class="bg-[#282c34] p-4 rounded overflow-auto max-h-[600px] border border-gray-800"></div>
    
    <script type="module" src="./dist/renderer/index.js"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "reqio-electron",
  "version": "1.0.0",
  "description": "App to test API endpoints using curl and electron",
  "license": "ISC",
  "author": "Sigmund Frost",
  "type": "commonjs",
  "main": "dist/main/index.js",
  "scripts": {
    "start": "npm run build:css && npm run build:ts && npm run build:renderer && electron .",
    "dev": "npm run watch:css & npm run watch:ts & npm run watch:renderer & electron .",
    "build:css": "tailwindcss -i ./src/styles/input.css -o ./styles.css",
    "watch:css": "tailwindcss -i ./src/styles/input.css -o ./styles.css --watch",
    "build:ts": "tsc",
    "watch:ts": "tsc --watch",
    "build:renderer": "esbuild src/renderer/index.ts --bundle --outfile=dist/renderer/index.js --format=esm --external:electron",
    "watch:renderer": "esbuild src/renderer/index.ts --bundle --outfile=dist/renderer/index.js --format=esm --external:electron --watch",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "devDependencies": {
    "@types/node": "^22.10.2",
    "electron": "^39.2.2",
    "esbuild": "^0.24.0",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.7.2"
  },
  "dependencies": {
    "highlight.js": "^11.9.0"
  }
}
</file>

</files>
